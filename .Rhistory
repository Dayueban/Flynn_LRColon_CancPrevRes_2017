kaitlin <- postdoc
kaitlin <- "postdoc"
install.packages("rmarkdown")
install.packages("knitr")
rm(list=ls())
install.packages(caret)
install.packages('caret')
library(caret)
pack_used <- c('randomForest','ggplot2', 'pROC', 'knitr','dplyr','AUCRF', 'tidyr', 'caret', 'RColorBrewer', 'reshape2', 'wesanderson')
for (dep in pack_used){
if (dep %in% installed.packages()[,"Package"] == FALSE){
install.packages(as.character(dep), repos = 'http://cran.us.r-project.org',
quiet=TRUE);
}
library(dep, verbose=FALSE, character.only=TRUE)
}
setwd("~/Documents/Schloss_Lab/KWS_Project")
setwd("~/Documents/Schloss_Lab/KWS_Project/Flynn_LRColon_XXXX_2017")
#just LB vs LS
left_otu_feat <- colnames(aucrf_data_left_bs[2:6])
pack_used <- c('randomForest','ggplot2', 'pROC', 'knitr','dplyr','AUCRF', 'tidyr', 'caret', 'RColorBrewer', 'reshape2', 'wesanderson')
for (dep in pack_used){
if (dep %in% installed.packages()[,"Package"] == FALSE){
install.packages(as.character(dep), repos = 'http://cran.us.r-project.org',
quiet=TRUE);
}
library(dep, verbose=FALSE, character.only=TRUE)
}
meta <- '../data/raw/kws_metadata.tsv'
shared <- '../data/mothur/kws_final.an.shared'
tax <- '../data/mothur/kws_final.an.cons.taxonomy'
subsample <- read.table(file='../data/mothur/kws_final.an.0.03.subsample.shared', header=T)
meta_file <- read.table(file='../data/raw/kws_metadata.tsv', header = T)
shared_file <- read.table(file='../data/mothur/kws_final.an.shared', sep = '\t', header=T, row.names=2)
tax_file <- read.table(file='../data/mothur/kws_final.an.cons.taxonomy', sep = '\t', header=T, row.names=1)
shared_meta <- merge(meta_file, shared_file, by.x='group', by.y='row.names')
simps <- read.table(file='../data/mothur/kws_final.an.groups.summary', header = T)
simpmeta <- merge(meta_file, simps)
tyc <- read.table(file ="../data/mothur/kws_final.an.summary", sep = '\t', header = T, row.names=NULL)
source('../code/Sum_OTU_by_Tax.R')
source('../code/sum_shared.R')
#use this code to assign phyla to each OTU in the shared file
sub <- '../data/mothur/kws_final.an.0.03.subsample.shared'
shared_phyla <- get_tax_level_shared(sub, tax, 2)
phyla_met <- merge(meta_file, shared_phyla, by.x='group', by.y='row.names')
#try to get the df organized to work as a boxplot - no median calculation
phyla_test <- phyla_met[, c("location","Firmicutes","Bacteroidetes","Proteobacteria","Verrucomicrobia","Actinobacteria","Fusobacteria")]
subsampled_to <- 4231
RA <- function(x) 100*x/subsampled_to
phyla_RA <- data.frame(phyla_test[1], apply(phyla_test[2:ncol(phyla_test)],2, RA))
phylaRAnames <- colnames(phyla_RA[,1:7])
phyla_RAmelt <- melt(phyla_RA[, phylaRAnames], id.vars=1)
tyc <- read.table("../data/mothur/kws_final.an.summary", sep = '\t', header = T, row.names=NULL)
#separate column values for comparisons
tyc <- separate(tyc, label, into= c('pt1', 'samp1'), sep="-", remove=F)
tyc <- separate(tyc, comparison, into= c('pt2', 'samp2'), sep="-", remove=F)
tyc <- subset(tyc, select = -c(row.names, X))
tyc <- subset(tyc, pt1==pt2)
tyc <- unite_(tyc, "match", from=c('samp1', 'samp2'), sep="_", remove = F)
stooltyc <- subset(tyc, match=='LB_RB' | match== 'LS_RS')
leftandrighttyc <- subset(tyc, match=='LB_LS' | match== 'RB_RS')
lvsr <- rbind(stooltyc, leftandrighttyc)
exittyc <- subset(tyc, samp2 == 'SS')
pvalues <- c()
Atyc <- subset(tyc, match=='RB_RS' | match=='LS_RS')
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=Atyc, paired=T)$p.value)
btyc <- subset(tyc, match=='RB_RS'| match=='LB_RB')
btyc <- btyc[-25,]
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=btyc, paired=T)$p.value)
ctyc <- subset(tyc, match=='RB_RS'| match=='LB_LS')
ctyc <- ctyc[-25,]
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=ctyc, paired=T)$p.value)
dtyc <- subset(tyc, match == 'LS_RS' | match == 'LB_RB')
dtyc <- dtyc[-25,]
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=dtyc, paired=T)$p.value)
etyc <- subset(tyc, match == 'LS_RS' | match == 'LB_LS')
etyc <- etyc[-25,]
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=etyc, paired=T)$p.value)
ftyc <- subset(tyc, match == 'LB_RB' | match == 'LB_LS')
pvalues <- c(pvalues, wilcox.test(thetayc~match, data=ftyc, paired=T)$p.value)
pvalues <- p.adjust(pvalues, method = "BH")
# now for exit comparisons
stoolpvalues <- c()
htyc <- subset(tyc, match=='RB_SS' | match=='RS_SS')
htyc <- htyc[-25,]
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=htyc, paired=T)$p.value)
ityc <- subset(tyc, match=='RB_SS' | match=='LB_SS')
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=ityc, paired=T)$p.value)
jtyc <- subset(tyc, match=='RB_SS' | match=='LS_SS')
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=jtyc, paired=T)$p.value)
ktyc <- subset(tyc, match=='RS_SS' | match=='LB_SS')
ktyc <- ktyc[-25,]
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=ktyc, paired=T)$p.value)
ltyc <- subset(tyc, match=='RS_SS' | match=='LS_SS')
ltyc <- ltyc[-25,]
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=ltyc, paired=T)$p.value)
mtyc <- subset(tyc, match=='LB_SS' | match=='LS_SS')
stoolpvalues <- c(stoolpvalues, wilcox.test(thetayc~match, data=mtyc, paired=T)$p.value)
stoolpvalues <- p.adjust(stoolpvalues, method = "BH")
alltyc <- read.table("../data/process/allshared.summary", sep = '\t', header = T, row.names=NULL)
alltyc <- separate(alltyc, label, into= c('pt1', 'samp1'), sep="-", remove=F)
alltyc <- separate(alltyc, comparison, into= c('pt2', 'samp2'), sep="-", remove=F)
alltyc <- alltyc[-1]
alltyc <- alltyc[-7]
#ultimately want a plot of all points where pt1 == pt2 in one bar and all of the others in another column
#unite and make column of 0/1 for matches? then can plot 1 and 0s
#should i separate out lumen and mucosa ? sure or no not for now
alltyc["same_pt"] <- NA
for (i in 1:nrow(alltyc)){
if (alltyc$pt1[i] == alltyc$pt2[i]){
alltyc$same_pt[i] <- 1
}
else alltyc$same_pt[i] <- 0
}
inter_medians <- aggregate(thetayc ~ same_pt, alltyc, median)
#create dataframe with relative abundances
rel_abund <- 100*shared_file/unique(apply(shared_file, 1, sum))
#Create vector of OTUs with median abundances >1%
OTUs_1 <- apply(rel_abund, 2, max) > 1
OTU_list <- colnames(rel_abund)[OTUs_1]
#get df of just top OTUs
rel_abund_top <- rel_abund[, OTUs_1]
rel_meta <- merge(meta_file, rel_abund_top, by.x='group', by.y="row.names")
seed <- 1
n_trees <- 2001
source('../code/random_functions.R')
#####RandomForest###########################################################################################
#build randomForest model for each location comparison using randomize_loc function
rf_left <- randomize_loc(rel_meta, "LB", "LS") #OOB 10.26%
rf_right <- randomize_loc(rel_meta, "RB", "RS") #OOB 53%
rf_bowel <- randomize_loc(rel_meta, "LB", "RB") #OOB 25.64%
rf_lumen <- randomize_loc(rel_meta, "LS", "RS") #OOB 69.23%
#and for each site
rf_all <- randomize_site(rel_meta, "mucosa", "stool")
#####AUCRF#####################################################################################
# create RF model with AUCRF outputs top OTUs
aucrf_data_left_bs <- auc_loc(rel_meta, "LB", "LS")
aucrf_data_LRbowel <- auc_loc(rel_meta, "LB", "RB")
aucrf_data_right_bs <- auc_loc(rel_meta, "RB", "RS")
aucrf_data_LRlumen <- auc_loc(rel_meta, "LS", "RS")
aucrf_data_allum <- auc_site(rel_meta, "mucosa", "stool")
########Cross-Validation#################################################################
#10 fold cross validation for all lumen vs mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp <- c()
cv10f_all_pred <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_allum),nrow(aucrf_data_allum),replace=F)
cv10f_probs <- rep(NA,78)
for(i in seq(1,77,7)){
train <- aucrf_data_allum[sampling[-(i:(i+6))],]
test <- aucrf_data_allum[sampling[i:(i+6)],]
set.seed(seed)
temp_model <- AUCRF(site~., data=train, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+6)]] <- predict(temp_model$RFopt, test, type='prob')[,2]
}
cv10f_roc <- roc(aucrf_data_allum$site~cv10f_probs)
cv10f_all_pred <- c(cv10f_all_pred, cv10f_probs)
cv10f_all_resp <- c(cv10f_all_resp, aucrf_data_allum$site)
cv10f_aucs[j] <- cv10f_roc$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc <- roc(cv10f_all_resp~cv10f_all_pred)
#10fold CV for L lumen vs L mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp_left_bs <- c()
cv10f_all_pred_left_bs <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_left_bs),nrow(aucrf_data_left_bs),replace=F)
cv10f_probs <- rep(NA,39)
for(i in seq(1,36,4)){
train_left_bs <- aucrf_data_left_bs[sampling[-(i:(i+3))],]
test_left_bs <- aucrf_data_left_bs[sampling[i:(i+3)],]
set.seed(seed)
temp_model_left_bs <- AUCRF(location~., data=train_left_bs, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+3)]] <- predict(temp_model_left_bs$RFopt, test_left_bs, type='prob')[,2]
}
cv10f_roc_left_bs <- roc(aucrf_data_left_bs$location~cv10f_probs)
cv10f_all_pred_left_bs <- c(cv10f_all_pred_left_bs, cv10f_probs)
cv10f_all_resp_left_bs <- c(cv10f_all_resp_left_bs, aucrf_data_left_bs$location)
cv10f_aucs[j] <- cv10f_roc_left_bs$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_left_bs <- roc(cv10f_all_resp_left_bs~cv10f_all_pred_left_bs)
#10fold CV for R lumen vs R mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp_right_bs <- c()
cv10f_all_pred_right_bs <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_right_bs),nrow(aucrf_data_right_bs),replace=F)
cv10f_probs <- rep(NA,39)
for(i in seq(1,36,4)){
train_right_bs <- aucrf_data_right_bs[sampling[-(i:(i+3))],]
test_right_bs <- aucrf_data_right_bs[sampling[i:(i+3)],]
set.seed(seed)
temp_model_right_bs <- AUCRF(location~., data=train_right_bs, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+3)]] <- predict(temp_model_right_bs$RFopt, test_right_bs, type='prob')[,2]
}
cv10f_roc_right_bs <- roc(aucrf_data_right_bs$location~cv10f_probs)
cv10f_all_pred_right_bs <- c(cv10f_all_pred_right_bs, cv10f_probs)
cv10f_all_resp_right_bs <- c(cv10f_all_resp_right_bs, aucrf_data_right_bs$location)
cv10f_aucs[j] <- cv10f_roc_right_bs$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_right_bs <- roc(cv10f_all_resp_right_bs~cv10f_all_pred_right_bs)
#10 fold cross validation for L vs R mucosa
iters <- 100
cv10f_aucs_muc <- c()
cv10f_all_resp_muc <- c()
cv10f_all_pred_muc <- c()
for(j in 1:iters){
set.seed(j)
sampling_muc <- sample(1:nrow(aucrf_data_LRbowel),nrow(aucrf_data_LRbowel),replace=F)
cv10f_probs_muc <- rep(NA,39)
for(i in seq(1,36,4)){
train_muc <- aucrf_data_LRbowel[sampling_muc[-(i:(i+3))],]
test_muc <- aucrf_data_LRbowel[sampling_muc[i:(i+3)],]
set.seed(seed)
temp_model_muc <- AUCRF(location~., data=train_muc, pdel=0.99, ntree=500)
cv10f_probs_muc[sampling_muc[i:(i+3)]] <- predict(temp_model_muc$RFopt, test_muc, type='prob')[,2]
}
cv10f_roc_muc <- roc(aucrf_data_LRbowel$location~cv10f_probs_muc)
cv10f_all_pred_muc <- c(cv10f_all_pred_muc, cv10f_probs_muc)
cv10f_all_resp_muc <- c(cv10f_all_resp_muc, aucrf_data_LRbowel$location)
cv10f_aucs_muc[j] <- cv10f_roc_muc$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_muc <- roc(cv10f_all_resp_muc~cv10f_all_pred_muc)
#10 fold cross validation for L vs R lumen
iters <- 100
cv10f_aucs_lum <- c()
cv10f_all_resp_lum <- c()
cv10f_all_pred_lum <- c()
for(j in 1:iters){
set.seed(j)
sampling_lum <- sample(1:nrow(aucrf_data_LRlumen),nrow(aucrf_data_LRlumen),replace=F)
cv10f_probs_lum <- rep(NA,39)
for(i in seq(1,36,4)){
train_lum <- aucrf_data_LRlumen[sampling_lum[-(i:(i+3))],]
test_lum <- aucrf_data_LRlumen[sampling_lum[i:(i+3)],]
set.seed(seed)
temp_model_lum <- AUCRF(location~., data=train_lum, pdel=0.99, ntree=500)
cv10f_probs_lum[sampling_lum[i:(i+3)]] <- predict(temp_model_lum$RFopt, test_lum, type='prob')[,2]
}
cv10f_roc_lum <- roc(aucrf_data_LRlumen$location~cv10f_probs_lum)
cv10f_all_pred_lum <- c(cv10f_all_pred_lum, cv10f_probs_lum)
cv10f_all_resp_lum <- c(cv10f_all_resp_lum, aucrf_data_LRlumen$location)
cv10f_aucs_lum[j] <- cv10f_roc_lum$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_lum <- roc(cv10f_all_resp_lum~cv10f_all_pred_lum)
View(aucrf_data_left_bs)
aucrf_data_left_bs <- auc_loc(rel_meta, "LB", "LS")
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp_left_bs <- c()
cv10f_all_pred_left_bs <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_left_bs),nrow(aucrf_data_left_bs),replace=F)
cv10f_probs <- rep(NA,39)
for(i in seq(1,36,4)){
train_left_bs <- aucrf_data_left_bs[sampling[-(i:(i+3))],]
test_left_bs <- aucrf_data_left_bs[sampling[i:(i+3)],]
set.seed(seed)
temp_model_left_bs <- AUCRF(location~., data=train_left_bs, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+3)]] <- predict(temp_model_left_bs$RFopt, test_left_bs, type='prob')[,2]
}
cv10f_roc_left_bs <- roc(aucrf_data_left_bs$location~cv10f_probs)
cv10f_all_pred_left_bs <- c(cv10f_all_pred_left_bs, cv10f_probs)
cv10f_all_resp_left_bs <- c(cv10f_all_resp_left_bs, aucrf_data_left_bs$location)
cv10f_aucs[j] <- cv10f_roc_left_bs$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_left_bs <- roc(cv10f_all_resp_left_bs~cv10f_all_pred_left_bs)
View(aucrf_data_left_bs)
View(aucrf_data_allum)
aucrf_data_left_bs <- auc_loc(rel_meta, "LB", "LS")
View(aucrf_data_left_bs)
View(rel_meta)
View(aucrf_data_allum)
View(aucrf_data_LRbowel)
aucrf_data_LRbowel <- auc_loc(rel_meta, "LB", "RB")
View(aucrf_data_LRbowel)
View(aucrf_data_left_bs)
subsetted <- subset(rel_meta, "LB", "LS")
subsetted <- subset(rel_meta, location %in% c("LB", "LS"))
View(subsetted)
subsetted$location <- factor(subsetted$location)
levels(subsetted$location) <- c(1:length(levels(subsetted$location))-1)
set.seed(seed)
rf_aucrf <- AUCRF(location ~ ., data = select(subsetted, location, contains("Otu")),
ntree = n_trees, pdel = 0.05, ranking = 'MDA')
otu_probs <- predict(rf_aucrf$RFopt, type = 'prob') #pull out predictive OTUs
View(otu_probs)
all_probs <- data.frame(obs = subsetted$location, pred = otu_probs[,2])
View(all_probs)
otu_roc <- roc(subsetted$location ~ otu_probs[,2])
otu_feat <- rf_aucrf$Xopt
meta_file <- read.table(file='data/raw/kws_metadata.tsv', header = T)
shared_file <- read.table(file='data/mothur/kws_final.an.shared', sep = '\t', header=T, row.names=2)
tax_file <- read.table(file='data/mothur/kws_final.an.cons.taxonomy', sep = '\t', header=T, row.names=1)
#make OTU abundance file
#Create df with relative abundances
shared_file <- subset(shared_file, select = -c(numOtus, label))
shared_meta <- merge(meta_file, shared_file, by.x='group', by.y='row.names')
rel_abund <- 100*shared_file/unique(apply(shared_file, 1, sum))
#Create vector of OTUs with median abundances >1%
OTUs_1 <- apply(rel_abund, 2, max) > 1
OTU_list <- colnames(rel_abund)[OTUs_1]
#get df of just top OTUs
rel_abund_top <- rel_abund[, OTUs_1]
rel_meta <- merge(meta_file, rel_abund_top, by.x='group', by.y="row.names")
seed <- 1
n_trees <- 2001
aucrf_data_left_bs <- auc_loc(rel_meta, "LB", "LS")
View(aucrf_data_left_bs)
#Create df with relative abundances
shared_file <- subset(shared_file, select = -c(numOtus, label))
shared_meta <- merge(meta_file, shared_file, by.x='group', by.y='row.names')
shared_file <- read.table(file='data/mothur/kws_final.an.shared', sep = '\t', header=T, row.names=2)
#make OTU abundance file
#Create df with relative abundances
shared_file_rf <- subset(shared_file, select = -c(numOtus, label))
shared_meta_rf <- merge(meta_file, shared_file, by.x='group', by.y='row.names')
#create dataframe with relative abundances
rel_abund <- 100*shared_file_rf/unique(apply(shared_file_rf, 1, sum))
#Create vector of OTUs with median abundances >1%
OTUs_1 <- apply(rel_abund, 2, max) > 1
OTU_list <- colnames(rel_abund)[OTUs_1]
#get df of just top OTUs
rel_abund_top <- rel_abund[, OTUs_1]
rel_meta <- merge(meta_file, rel_abund_top, by.x='group', by.y="row.names")
seed <- 1
n_trees <- 2001
source('../code/random_functions.R')
#####RandomForest###########################################################################################
#build randomForest model for each location comparison using randomize_loc function
rf_left <- randomize_loc(rel_meta, "LB", "LS") #OOB 10.26%
rf_right <- randomize_loc(rel_meta, "RB", "RS") #OOB 53%
rf_bowel <- randomize_loc(rel_meta, "LB", "RB") #OOB 25.64%
rf_lumen <- randomize_loc(rel_meta, "LS", "RS") #OOB 69.23%
#and for each site
rf_all <- randomize_site(rel_meta, "mucosa", "stool")
#####AUCRF#####################################################################################
# create RF model with AUCRF outputs top OTUs
aucrf_data_left_bs <- auc_loc(rel_meta, "LB", "LS")
aucrf_data_LRbowel <- auc_loc(rel_meta, "LB", "RB")
aucrf_data_right_bs <- auc_loc(rel_meta, "RB", "RS")
aucrf_data_LRlumen <- auc_loc(rel_meta, "LS", "RS")
aucrf_data_allum <- auc_site(rel_meta, "mucosa", "stool")
########Cross-Validation#################################################################
#10 fold cross validation for all lumen vs mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp <- c()
cv10f_all_pred <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_allum),nrow(aucrf_data_allum),replace=F)
cv10f_probs <- rep(NA,78)
for(i in seq(1,77,7)){
train <- aucrf_data_allum[sampling[-(i:(i+6))],]
test <- aucrf_data_allum[sampling[i:(i+6)],]
set.seed(seed)
temp_model <- AUCRF(site~., data=train, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+6)]] <- predict(temp_model$RFopt, test, type='prob')[,2]
}
cv10f_roc <- roc(aucrf_data_allum$site~cv10f_probs)
cv10f_all_pred <- c(cv10f_all_pred, cv10f_probs)
cv10f_all_resp <- c(cv10f_all_resp, aucrf_data_allum$site)
cv10f_aucs[j] <- cv10f_roc$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc <- roc(cv10f_all_resp~cv10f_all_pred)
#10fold CV for L lumen vs L mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp_left_bs <- c()
cv10f_all_pred_left_bs <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_left_bs),nrow(aucrf_data_left_bs),replace=F)
cv10f_probs <- rep(NA,39)
for(i in seq(1,36,4)){
train_left_bs <- aucrf_data_left_bs[sampling[-(i:(i+3))],]
test_left_bs <- aucrf_data_left_bs[sampling[i:(i+3)],]
set.seed(seed)
temp_model_left_bs <- AUCRF(location~., data=train_left_bs, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+3)]] <- predict(temp_model_left_bs$RFopt, test_left_bs, type='prob')[,2]
}
cv10f_roc_left_bs <- roc(aucrf_data_left_bs$location~cv10f_probs)
cv10f_all_pred_left_bs <- c(cv10f_all_pred_left_bs, cv10f_probs)
cv10f_all_resp_left_bs <- c(cv10f_all_resp_left_bs, aucrf_data_left_bs$location)
cv10f_aucs[j] <- cv10f_roc_left_bs$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_left_bs <- roc(cv10f_all_resp_left_bs~cv10f_all_pred_left_bs)
#10fold CV for R lumen vs R mucosa
iters <- 100
cv10f_aucs <- c()
cv10f_all_resp_right_bs <- c()
cv10f_all_pred_right_bs <- c()
for(j in 1:iters){
set.seed(j)
sampling <- sample(1:nrow(aucrf_data_right_bs),nrow(aucrf_data_right_bs),replace=F)
cv10f_probs <- rep(NA,39)
for(i in seq(1,36,4)){
train_right_bs <- aucrf_data_right_bs[sampling[-(i:(i+3))],]
test_right_bs <- aucrf_data_right_bs[sampling[i:(i+3)],]
set.seed(seed)
temp_model_right_bs <- AUCRF(location~., data=train_right_bs, pdel=0.99, ntree=500)
cv10f_probs[sampling[i:(i+3)]] <- predict(temp_model_right_bs$RFopt, test_right_bs, type='prob')[,2]
}
cv10f_roc_right_bs <- roc(aucrf_data_right_bs$location~cv10f_probs)
cv10f_all_pred_right_bs <- c(cv10f_all_pred_right_bs, cv10f_probs)
cv10f_all_resp_right_bs <- c(cv10f_all_resp_right_bs, aucrf_data_right_bs$location)
cv10f_aucs[j] <- cv10f_roc_right_bs$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_right_bs <- roc(cv10f_all_resp_right_bs~cv10f_all_pred_right_bs)
#10 fold cross validation for L vs R mucosa
iters <- 100
cv10f_aucs_muc <- c()
cv10f_all_resp_muc <- c()
cv10f_all_pred_muc <- c()
for(j in 1:iters){
set.seed(j)
sampling_muc <- sample(1:nrow(aucrf_data_LRbowel),nrow(aucrf_data_LRbowel),replace=F)
cv10f_probs_muc <- rep(NA,39)
for(i in seq(1,36,4)){
train_muc <- aucrf_data_LRbowel[sampling_muc[-(i:(i+3))],]
test_muc <- aucrf_data_LRbowel[sampling_muc[i:(i+3)],]
set.seed(seed)
temp_model_muc <- AUCRF(location~., data=train_muc, pdel=0.99, ntree=500)
cv10f_probs_muc[sampling_muc[i:(i+3)]] <- predict(temp_model_muc$RFopt, test_muc, type='prob')[,2]
}
cv10f_roc_muc <- roc(aucrf_data_LRbowel$location~cv10f_probs_muc)
cv10f_all_pred_muc <- c(cv10f_all_pred_muc, cv10f_probs_muc)
cv10f_all_resp_muc <- c(cv10f_all_resp_muc, aucrf_data_LRbowel$location)
cv10f_aucs_muc[j] <- cv10f_roc_muc$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_muc <- roc(cv10f_all_resp_muc~cv10f_all_pred_muc)
#10 fold cross validation for L vs R lumen
iters <- 100
cv10f_aucs_lum <- c()
cv10f_all_resp_lum <- c()
cv10f_all_pred_lum <- c()
for(j in 1:iters){
set.seed(j)
sampling_lum <- sample(1:nrow(aucrf_data_LRlumen),nrow(aucrf_data_LRlumen),replace=F)
cv10f_probs_lum <- rep(NA,39)
for(i in seq(1,36,4)){
train_lum <- aucrf_data_LRlumen[sampling_lum[-(i:(i+3))],]
test_lum <- aucrf_data_LRlumen[sampling_lum[i:(i+3)],]
set.seed(seed)
temp_model_lum <- AUCRF(location~., data=train_lum, pdel=0.99, ntree=500)
cv10f_probs_lum[sampling_lum[i:(i+3)]] <- predict(temp_model_lum$RFopt, test_lum, type='prob')[,2]
}
cv10f_roc_lum <- roc(aucrf_data_LRlumen$location~cv10f_probs_lum)
cv10f_all_pred_lum <- c(cv10f_all_pred_lum, cv10f_probs_lum)
cv10f_all_resp_lum <- c(cv10f_all_resp_lum, aucrf_data_LRlumen$location)
cv10f_aucs_lum[j] <- cv10f_roc_lum$auc #stores aucs for all iterations, can use to calc IQR
}
cv10f_roc_lum <- roc(cv10f_all_resp_lum~cv10f_all_pred_lum)
#just LB vs LS
left_otu_feat <- colnames(aucrf_data_left_bs[2:6])
otu_taxa_left <- get_tax(1, left_otu_feat, tax_file)
otu_taxa_all <- get_tax(1, all_otu_feat, tax_file)
source('code/tax_level.R')
source('../code/tax_level.R')
#just LB vs LS
left_otu_feat <- colnames(aucrf_data_left_bs[2:6])
otu_taxa_left <- get_tax(1, left_otu_feat, tax_file)
#Abundance stripchart or most predictive otus
ls_abunds <- shared_meta[shared_meta$location=='LS', left_otu_feat]/10000 + 1e-4
lb_abunds <- shared_meta[shared_meta$location=='LB', left_otu_feat]/10000 + 1e-4
right_otu_feat <- colnames(aucrf_data_right_bs[2:6])
otu_taxa_right <- get_tax(1, right_otu_feat, tax_file)
#Abundance stripchart or most predictive otus
rs_abunds <- shared_meta[shared_meta$location=='RS', right_otu_feat]/10000 + 1e-4
rb_abunds <- shared_meta[shared_meta$location=='RB', right_otu_feat]/10000 + 1e-4
#Lb vs Rb
LRbowel_otu_feat <- colnames(aucrf_data_LRbowel[2:6])
otu_taxa_LRbowel <- get_tax(1, LRbowel_otu_feat, tax_file)
#Abundance stripchart or most predictive otus
lb_abunds <- shared_meta[shared_meta$location=='LB', LRbowel_otu_feat]/10000 + 1e-4
rblb_abunds <- shared_meta[shared_meta$location=='RB', LRbowel_otu_feat]/10000 + 1e-4
#LS vs RS
LRlumen_otu_feat <- colnames(aucrf_data_LRlumen[2:6])
otu_taxa_LRlumen <- get_tax(1, LRlumen_otu_feat, tax_file)
#Abundance stripchart or most predictive otus
lsrs_abunds <- shared_meta[shared_meta$location=='LS', LRlumen_otu_feat]/10000 + 1e-4
rsls_abunds <- shared_meta[shared_meta$location=='RS', LRlumen_otu_feat]/10000 + 1e-4
knitr::opts_chunk$set("tidy" = TRUE)
opts_chunk$set("echo" = FALSE)
opts_chunk$set("eval" = TRUE)
opts_chunk$set("warning" = FALSE)
opts_chunk$set("cache" = FALSE)
inline_hook <- function(x){
print(x)
if(is.list(x)){
x <- unlist(x)
}
if(is.numeric(x)){
if(abs(x - round(x)) < .Machine$double.eps^0.5){
paste(format(x,big.mark=',', digits=0, scientific=FALSE))
} else {
paste(format(x,big.mark=',', digits=1, nsmall=1, scientific=FALSE))
}
} else {
paste(x)
}
}
knitr::knit_hooks$set(inline=inline_hook)
